[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Results",
    "section": "",
    "text": "26 zone thin high CO2 cost\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n26 zone thin\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n26 zone thin no CO2 cap\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notebooks/test.html",
    "href": "notebooks/test.html",
    "title": "MIP",
    "section": "",
    "text": "folder = \"26z-thin-debug\"\nimport os\nfrom typing import Dict, List\n\nimport pandas as pd\n\n# import geopandas as gpd\nimport altair as alt\nfrom pathlib import Path\n\nalt.renderers.enable(\"html\")\n\n# alt.renderers.enable(\"png\")\ncwd = Path.cwd()\ndata_path = cwd.parent / folder\n# gdf = gpd.read_file(\"conus_26z_latlon.geojson\")\n# gdf = gdf.rename(columns={\"model_region\": \"zone\"})\n# gdf[\"lat\"] = gdf.geometry.centroid.y\n# gdf[\"lon\"] = gdf.geometry.centroid.x\n\nprint(\"\\n\\nstarting figure script\\n\\n\")\n\nregion_map = {\n    \"WECC\": [\"BASN\", \"CANO\", \"CASO\", \"NWPP\", \"SRSG\", \"RMRG\"],\n    \"TRE\": [\"TRE\", \"TRE_WEST\"],\n    \"SPP\": [\"SPPC\", \"SPPN\", \"SPPS\"],\n    \"MISO\": [\"MISC\", \"MISE\", \"MISS\", \"MISW\", \"SRCE\"],\n    \"PJM\": [\"PJMC\", \"PJMW\", \"PJME\", \"PJMD\"],\n    \"SOU\": [\"SRSE\", \"SRCA\", \"FRCC\"],\n    \"NE\": [\"ISNE\", \"NYUP\", \"NYCW\"],\n}\n\nTECH_MAP = {\n    \"batteries\": \"Battery\",\n    \"biomass_\": \"Other\",\n    \"conventional_hydroelectric\": \"Hydro\",\n    \"conventional_steam_coal\": \"Coal\",\n    \"geothermal\": \"Geothermal\",\n    \"natural_gas_fired_combined_cycle\": \"Natural Gas CC\",\n    \"natural_gas_fired_combustion_turbine\": \"Natural Gas CT\",\n    \"natural_gas_internal_combustion_engine\": \"Natural Gas Other\",\n    \"natural_gas_steam_turbine\": \"Natural Gas Other\",\n    \"onshore_wind_turbine\": \"Wind\",\n    \"petroleum_liquids\": \"Other\",\n    \"small_hydroelectric\": \"Hydro\",\n    \"solar_photovoltaic\": \"Solar\",\n    \"hydroelectric_pumped_storage\": \"Hydro\",\n    \"nuclear\": \"Nuclear\",\n    \"offshore_wind_turbine\": \"Wind\",\n    \"distributed_generation\": \"Distributed Solar\",\n    \"naturalgas_ccavgcf\": \"Natural Gas CC\",\n    \"naturalgas_ctavgcf\": \"Natural Gas CT\",\n    \"battery\": \"Battery\",\n    \"landbasedwind\": \"Wind\",\n    \"utilitypv\": \"Solar\",\n    \"naturalgas_ccccsavgcf\": \"CCS\",\n    \"ccs\": \"CCS\",\n    \"offshorewind\": \"Wind\",\n    \"hydrogen\": \"Hydrogen\",\n}\n\n\ndef tech_to_type(df: pd.DataFrame) -&gt; pd.DataFrame:\n    for tech, type in TECH_MAP.items():\n        df.loc[df[\"resource_name\"].str.contains(tech), \"tech_type\"] = type\n\n    return df\n\n\ndef reverse_dict_of_lists(d: Dict[str, list]) -&gt; Dict[str, List[str]]:\n    \"\"\"Reverse the mapping in a dictionary of lists so each list item maps to the key\n\n    Parameters\n    ----------\n    d : Dict[str, List[str]]\n        A dictionary with string keys and lists of strings.\n\n    Returns\n    -------\n    Dict[str, str]\n        A reverse mapped dictionary where the item of each list becomes a key and the\n        original keys are mapped as values.\n    \"\"\"\n    if isinstance(d, dict):\n        rev = {v: k for k in d for v in d[k]}\n    else:\n        rev = dict()\n    return rev\n\n\nrev_region_map = reverse_dict_of_lists(region_map)\n\nfig_num = 0\nimport os\nfrom typing import Dict, List\n\nos.environ[\"USE_PYGEOS\"] = \"0\"\n\nimport pandas as pd\n\n# import geopandas as gpd\nimport altair as alt\nfrom pathlib import Path\n\nalt.renderers.enable(\"html\")\n\n# alt.renderers.enable(\"png\")\ncwd = Path.cwd()\ndata_path = cwd.parent / folder\n# gdf = gpd.read_file(\"conus_26z_latlon.geojson\")\n# gdf = gdf.rename(columns={\"model_region\": \"zone\"})\n# gdf[\"lat\"] = gdf.geometry.centroid.y\n# gdf[\"lon\"] = gdf.geometry.centroid.x\n\nprint(\"\\n\\nstarting figure script\\n\\n\")\n\nregion_map = {\n    \"WECC\": [\"BASN\", \"CANO\", \"CASO\", \"NWPP\", \"SRSG\", \"RMRG\"],\n    \"TRE\": [\"TRE\", \"TRE_WEST\"],\n    \"SPP\": [\"SPPC\", \"SPPN\", \"SPPS\"],\n    \"MISO\": [\"MISC\", \"MISE\", \"MISS\", \"MISW\", \"SRCE\"],\n    \"PJM\": [\"PJMC\", \"PJMW\", \"PJME\", \"PJMD\"],\n    \"SOU\": [\"SRSE\", \"SRCA\", \"FRCC\"],\n    \"NE\": [\"ISNE\", \"NYUP\", \"NYCW\"],\n}\n\nTECH_MAP = {\n    \"batteries\": \"Battery\",\n    \"biomass_\": \"Other\",\n    \"conventional_hydroelectric\": \"Hydro\",\n    \"conventional_steam_coal\": \"Coal\",\n    \"geothermal\": \"Geothermal\",\n    \"natural_gas_fired_combined_cycle\": \"Natural Gas CC\",\n    \"natural_gas_fired_combustion_turbine\": \"Natural Gas CT\",\n    \"natural_gas_internal_combustion_engine\": \"Natural Gas Other\",\n    \"natural_gas_steam_turbine\": \"Natural Gas Other\",\n    \"onshore_wind_turbine\": \"Wind\",\n    \"petroleum_liquids\": \"Other\",\n    \"small_hydroelectric\": \"Hydro\",\n    \"solar_photovoltaic\": \"Solar\",\n    \"hydroelectric_pumped_storage\": \"Hydro\",\n    \"nuclear\": \"Nuclear\",\n    \"offshore_wind_turbine\": \"Wind\",\n    \"distributed_generation\": \"Distributed Solar\",\n    \"naturalgas_ccavgcf\": \"Natural Gas CC\",\n    \"naturalgas_ctavgcf\": \"Natural Gas CT\",\n    \"battery\": \"Battery\",\n    \"landbasedwind\": \"Wind\",\n    \"utilitypv\": \"Solar\",\n    \"naturalgas_ccccsavgcf\": \"CCS\",\n    \"ccs\": \"CCS\",\n    \"offshorewind\": \"Wind\",\n    \"hydrogen\": \"Hydrogen\",\n}\n\n\ndef tech_to_type(df: pd.DataFrame) -&gt; pd.DataFrame:\n    for tech, type in TECH_MAP.items():\n        df.loc[df[\"resource_name\"].str.contains(tech), \"tech_type\"] = type\n\n    return df\n\n\ndef reverse_dict_of_lists(d: Dict[str, list]) -&gt; Dict[str, List[str]]:\n    \"\"\"Reverse the mapping in a dictionary of lists so each list item maps to the key\n\n    Parameters\n    ----------\n    d : Dict[str, List[str]]\n        A dictionary with string keys and lists of strings.\n\n    Returns\n    -------\n    Dict[str, str]\n        A reverse mapped dictionary where the item of each list becomes a key and the\n        original keys are mapped as values.\n    \"\"\"\n    if isinstance(d, dict):\n        rev = {v: k for k in d for v in d[k]}\n    else:\n        rev = dict()\n    return rev\n\n\nrev_region_map = reverse_dict_of_lists(region_map)\n\n\ndef load_data(data_path: Path, fn: str) -&gt; pd.DataFrame:\n    df_list = []\n    for f in data_path.rglob(fn):\n        if not \"output\" in f.parts[-2]:\n            # print(f.parts[-2])\n            _df = pd.read_csv(f)\n            df_list.append(_df)\n    df = pd.concat(df_list, ignore_index=True)\n    if \"resource_name\" in df.columns:\n        df = tech_to_type(df)\n        df = df.query(\"~tech_type.str.contains('Other')\")\n    if \"line_name\" in df.columns:\n        df = fix_tx_line_names(df)\n    if \"zone\" in df.columns:\n        df[\"agg_zone\"] = df[\"zone\"].map(rev_region_map)\n\n    return df\n\n\ndef load_genx_operations_data(data_path: Path, fn: str) -&gt; pd.DataFrame:\n    df_list = []\n    for f in data_path.rglob(fn):\n        _df = pd.read_csv(f)\n        model = f.parts[-3].split(\"_\")[0]\n        _df[\"model\"] = model\n        df_list.append(_df)\n\n    df = pd.concat(df_list, ignore_index=True)\n    return df\n\n\ndef reverse_line_name(s: str) -&gt; str:\n    segments = s.split(\"_to_\")\n    return segments[-1] + \"_to_\" + segments[0]\n\n\ndef fix_tx_line_names(df: pd.DataFrame) -&gt; pd.DataFrame:\n    line_count = df.groupby(\"line_name\", as_index=False)[\"model\"].count()\n    median_count = line_count[\"model\"].median()\n    reversed_lines = line_count.query(\"model &lt; @median_count\")\n\n    for idx, row in reversed_lines.iterrows():\n        df[\"line_name\"] = df[\"line_name\"].str.replace(\n            row[\"line_name\"], reverse_line_name(row[\"line_name\"])\n        )\n\n    return df\n\n\nfig_num = 0\n\ncap = load_data(data_path, \"resource_capacity.csv\")\ncap = cap.query(\"unit=='MW' and not tech_type.isna()\")\ncap[\"additions\"] = cap[\"end_value\"] - cap[\"start_value\"]\n\ngen = load_data(data_path, \"generation.csv\")\n\ntx = load_data(data_path, \"transmission.csv\")\n\n\ntx[\"start_region\"] = tx[\"line_name\"].str.split(\"_to_\").str[0]\ntx[\"dest_region\"] = tx[\"line_name\"].str.split(\"_to_\").str[1]\n# tx[\"lat1\"] = tx[\"start_region\"].map(gdf.set_index(\"zone\")[\"lat\"])\n# tx[\"lon1\"] = tx[\"start_region\"].map(gdf.set_index(\"zone\")[\"lon\"])\n# tx[\"lat2\"] = tx[\"dest_region\"].map(gdf.set_index(\"zone\")[\"lat\"])\n# tx[\"lon2\"] = tx[\"dest_region\"].map(gdf.set_index(\"zone\")[\"lon\"])\n\nfirst_year = tx[\"planning_year\"].min()\nstarting_tx = tx.loc[tx[\"planning_year\"] == first_year, :]\nstarting_tx = starting_tx.rename(columns={\"start_value\": \"value\"})\nstarting_tx[\"planning_year\"] = 2023\n# %%\ntx_exp = load_data(data_path, \"transmission_expansion.csv\")\ntx_exp[\"start_region\"] = tx_exp[\"line_name\"].str.split(\"_to_\").str[0]\ntx_exp[\"dest_region\"] = tx_exp[\"line_name\"].str.split(\"_to_\").str[1]\n\nemiss = load_data(data_path, \"emissions.csv\")\n\nemiss.loc[emiss[\"unit\"] == \"kg\", \"value\"] /= 1000\n\n\n\n\nstarting figure script\n\n\n\n\nstarting figure script\n\n\n\n\n/var/folders/nr/y3csklpd0l77v_k39y46s2rc0000gn/T/ipykernel_93742/3289126654.py:202: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  df[\"agg_zone\"] = df[\"zone\"].map(rev_region_map)\n/var/folders/nr/y3csklpd0l77v_k39y46s2rc0000gn/T/ipykernel_93742/3289126654.py:202: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  df[\"agg_zone\"] = df[\"zone\"].map(rev_region_map)\n\n\n\nif not \"output\" in \"outputs\":\n    print(\"yes\")\n\n\n\ndispatch = load_data(data_path, \"dispatch.csv\")\n\n/var/folders/nr/y3csklpd0l77v_k39y46s2rc0000gn/T/ipykernel_93742/3289126654.py:202: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  df[\"agg_zone\"] = df[\"zone\"].map(rev_region_map)\n\n\n\n\ndispatch = dispatch.groupby(\n    [\n        \"planning_year\",\n        \"model\",\n        \"agg_zone\",\n        \"zone\",\n        \"tech_type\",\n        \"resource_name\",\n        \"hour\",\n    ],\n    as_index=False,\n)[\"value\"].sum()\ngroup_cols = [\"planning_year\", \"model\", \"agg_zone\", \"zone\", \"tech_type\"]\nhours = dispatch[\"hour\"].unique()\nindex_cols = [\"resource_name\"]\ndf_list = []\nfor _, _df in dispatch.groupby(group_cols):\n    multi_index = pd.MultiIndex.from_product(\n        [_df[col].unique() for col in index_cols] + [hours],\n        names=index_cols + [\"hour\"],\n    )\n    _df = _df.set_index(index_cols + [\"hour\"])\n    _df = _df.reindex(index=multi_index, fill_value=0)\n    _df = _df.reset_index()\n    for val, col in zip(_, group_cols):\n        _df[col] = val\n    df_list.append(_df)\n\ndispatch = pd.concat(df_list, ignore_index=True)"
  }
]